#!/usr/bin/env perl

use warnings;
use strict;
use v5.22.0;

no warnings 'experimental::smartmatch';

use Image::ExifTool qw/:Public/;
use File::Temp qw/tempdir/;
use File::Find::Rule;
use File::Path qw/make_path/;
use File::Copy qw/cp/;
use Furl;
use JSON;
use Carp;
use List::Util qw/first/;
use Digest::SHA qw/sha256_hex/;
use Time::Piece;
use Data::Dumper;

use constant MONTH => [
  qw/_ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/
];

my $furl = Furl->new(
  headers => [ 'Accept-Encoding' => 'gzip' ],
);

die "Usage: $0 [files...] [target]\n" unless @ARGV > 1;
my $target = pop @ARGV;
die "$target is not a directory" unless -d $target;
processFile($_, $target) for grep { $_ !~ m|/\.[^/]+$| } files(@ARGV);

sub files {
  return map {
    -d $_ ? findFiles($_) :
    -e $_ ? $_ : die "Could not find file $_";
  } @_;
}

sub findFiles {
  File::Find::Rule->file->name(qr/\.(mov|mp4|avi)$/i)->in(shift);
}

sub formatDate {
  my ($date, $time) = split " ", shift;
  $date =~ tr/:/-/;
  $time =~ s/([+-].*)$/.0$1/;
  return "${date}T${time}";
}

sub extractRecords {
  my $info = shift;
  my $records = {};
  for (keys %$info) {
    next unless /^AcquisitionRecordGroupItem(Name|Value)(.*)/;
    $records->{$2}{$1} = $info->{$_};
  }
  return { map { $_->{Name} => $_->{Value} } values %$records };
}

sub extractTitle {
  my ($title) = shift =~ m|^(?:.*/)?(.*)(?:\..+?)$|;
  return $title;
}

sub formatSonyLatLong {
  return undef unless defined $_[0];
  my ($deg, $min, $sec) = split ":", shift;
  return (shift ~~ [qw/S W/] ? "-": "") . ($deg + ($min / 60) + ($sec / 3600));
}

sub formatIPhoneLatLong {
  return undef unless defined $_[0];
  my ($deg, $min, $sec, $direction) = shift =~ /^(\d+) deg (\d+)' ([\d.]+)" ([NWSE])$/;
  return ($direction ~~ [qw/S W/] ? "-": "") . ($deg + ($min / 60) + ($sec / 3600));
}

sub place {
  my ($lat, $long) = @{$_[0]}{qw/latitude longitude/};
  return undef unless defined $lat && defined $long;

  my $res = decode_json $furl->get("https://maps.googleapis.com/maps/api/geocode/json?latlng=$lat,$long&sensor=true")->content;
  return undef if $res->{status} eq "ZERO_RESULTS";
  confess "Result no OK: " . Dumper $res unless $res->{status} eq "OK"; 

  my $match = $res->{results}[0]{address_components};
  confess "Failed to get match: " . Dumper $res unless $match;

  my $neighborhood = first { $_->{types}[0] eq "neighborhood" } @$match;
  my $locality     = first { $_->{types}[0] eq "locality"     } @$match;
  confess "Failed to gey locality: " . Dumper $match unless $locality;
  return $neighborhood ? "$neighborhood->{long_name} ($locality->{long_name})" : $locality->{long_name};
}

sub sonyInfo {
  my $info    = shift;
  my $records = extractRecords($info);
  return {
    camera    => "Sony Î±6500",
    date      => formatDate($info->{CreationDateValue}),
    latitude  => formatSonyLatLong($records->{Latitude},  $records->{LatitudeRef}),
    longitude => formatSonyLatLong($records->{Longitude}, $records->{LongitudeRef}),
    filters   => ($records->{SpeedRef} ? [
      "eq=contrast=1.8:saturation=2.8:brightness=0.2",
      "curves=r='0/0 0.52/0.58 1/1':m='0/0.05 0.2/0.27 0.5/0.6 0.7/0.8 1/1'",
      "unsharp",
    ] : undef),
  }
}

sub canonInfo {
  my $info = shift;
  return {
    camera  => "Canon 60D",
    lens    => $info->{LensID},
    date    => formatDate($info->{MediaCreateDate} . "-05:00"),
    filters => [
      "eq=contrast=1.8:saturation=2.8:brightness=0.2",
      "curves=r='0/0 0.52/0.58 1/1':m='0/0.05 0.2/0.27 0.5/0.6 0.7/0.8 1/1'",
      "unsharp",
    ]
  }
}

sub iPhoneInfo {
  my $info = shift;
  return {
    camera    => $info->{Model},
    date      => formatDate($info->{CreationDate}),
    latitude  => formatIPhoneLatLong($info->{GPSLatitude}),
    longitude => formatIPhoneLatLong($info->{GPSLongitude}),
  }
}

sub generalInfo {
  my $info = shift;
  return {
    camera    => $info->{Model},
    date      => formatDate($info->{CreationDate}),
    latitude  => formatIPhoneLatLong($info->{GPSLatitude}),
    longitude => formatIPhoneLatLong($info->{GPSLongitude}),
  }
}

sub prettyDate {
  my ($date) = shift =~ /^(\d+-\d+-\d+T\d+:\d+):/;
  return Time::Piece->strptime($date, "%Y-%m-%dT%H:%M")->strftime("%A, %B %e, %Y, %I:%M %p");
}

sub description {
  my ($sha, $place, $info) = @_;
  my $description = join " ", map { "$_." } grep { defined } prettyDate($info->{date}), $place, @{$info}{qw/place camera lens/};
  return $description . "\n\n$sha";
}

sub cameraInfo {
  my $info = shift;
  return sonyInfo($info)    if $info->{DeviceModelName} // "" eq "ILCE-6500";
  return canonInfo($info)   if $info->{Model} eq "Canon EOS 60D";
  return iPhoneInfo($info)  if $info->{Model} =~ /iPhone/;
  return generalInfo($info) if $info->{Model};
  confess "Failed to figure out the model: " . Dumper $info;
}

sub extractInfo {
  my $file       = shift;
  my $sha        = sha256_hex($file);
  my $info       = { %{ImageInfo($file)}, PreviewImage => undef };
  my $cameraInfo = cameraInfo($info);
  my $place      = place($cameraInfo);

  return {
    %$cameraInfo,
    title       => extractTitle($file),
    sha         => $sha,
    place       => $place,
    description => description($sha, $place, $cameraInfo),
  }
}

sub randomString {
  my @chars = ("A".."Z", "a".."z", "0".."9");
  return join "", @chars[map { rand @chars } 1..10];
}

sub filename {
  return shift . "/" . randomString() . ".mp4";
}

sub grade {
  my ($file, $dir, $info) = @_;
  return $file unless $info->{filters};
  my $out = filename($dir);
  system(
    "ffmpeg",
    -threads => 0,
    -i       => $file,
    -vf      => join(",", @{$info->{filters}}),
    -pix_fmt => "yuv420p",
    -crf     => 18,
    "-c:v"   => "libx264",
    $out
  );
  return $out;
}

use constant DELAY => 30;
my $last;
sub upload {
  my ($file, $info) = @_;
  my $wait = $last ? DELAY - (time - $last) : 0;
  if ($wait > 0) {
    say "Waiting for $wait seconds";
    sleep $wait;
  }
  $last = time;

  system(
    "youtube-upload",
    "--title"                  => $info->{title},
    "--description"            => $info->{description},
    "--category"               => "People & Blogs",
    "--tags"                   => "family, home-movies",
    "--recording-date"         => $info->{date},
    "--playlist"               => "Home movies",
    "--default-language"       => "en",
    "--default-audio-language" => "en",
    "--privacy"                => "private",
    ($info->{latitude} && $info->{longitude} ? ("--location" => "latitude=$info->{latitude},longitude=$info->{longitude}") : ()),
    $file,
  ) == 0 or die "Upload failed: $?";
}

sub findDirectory {
  my ($target, $year, $day) = @_;
  return unless -d "$target/$year";
  opendir my $dir, "$target/$year" or confess "Failed to open directory: $!";
  my ($directory) = first { m|^$target/$year/$day| } readdir $dir;
  closedir $dir;
  return $directory;
}

sub copy {
  my ($file, $target, $info) = @_;
  my ($year, $day) = $info->{date} =~ /^(\d+)-(\d\d-\d\d)/;
  my ($extension) = map { lc } $file =~ /.([\w]+)$/;

  # find directory
  my $directory = findDirectory($target, $year, $day);
  if (!$directory) {
    $directory = $info->{place} ? "$target/$year/$day $info->{place}" : "$target/$year/$day";
    make_path $directory;
  }
  elsif ($directory !~ /$info->{place}/) {
    my $new = length($directory) == 10 ?  "$directory $info->{place}" : "$directory, $info->{place}";
    rename $directory, $new;
    $directory = $new;
  }

  my $destination = "$directory/$info->{sha}.$extension";
  if (-e $destination) {
    say "Target $destination exists";
    return;
  }

  cp $file, $destination;
}

sub processFile {
  my $file   = shift;
  my $target = shift;
  my $info   = extractInfo($file);
  my $dir    = tempdir();
  say "Processing $file";
  say Dumper $info;

  # copy file to target
  return unless copy($file, $target, $info);

  # upload
  upload(grade($file, $dir, $info), $info);
}
